'''
@author: Shihui Liu

Use gen_traj() to generate trapezoidal trajectories given parameters generated by HKA
Use hka_profile_opt() to optimize robot energy consumption given a set of randomly generated trapezoidal trajectories using HKA
Uncomment the last section of the code to visualize the trajectories in joint space.
'''

from math import pi
import numpy as np
from roboticstoolbox import tools as tools
import matplotlib.pyplot as plt
from call_tau import *
from scipy.stats import truncnorm
from plot_traj import *
from traj import *
from HKA_kalman_gain import *
from energy_est import *
import time as ti

def gen_traj(vel_max, t_accel_rand, q0, qf, tf, time, V=None):
    """
    Generate a trapezoidal trajectory in joint space given parameters generated by HKA
    :param vel_max: maximal (allowed) angular velocity of the robot joint
    :param t_accel_rand: the acceleration time, randomly generated by HKA
    :param q0: initial joint angle at t = 0
    :param qf: end joint angle at t = tf
    :param tf: trajectory time
    :param time: the discretized time array, with time[0] = 0, time[-1] = tf
    :return q: array of joint angle with the size of len(time)
    :return qd: array of joint velocity with the size of len(time)
    :return qdd: array of joint acceleration with the size of len(time)
    """
    q = []
    qd = []
    qdd = []

    if V is None:
        # if velocity not specified, compute it
        V = (qf - q0) / tf * 1.5
    else:
        V = abs(V) * np.sign(qf - q0)
        if abs(V) < (abs(qf - q0) / tf):
            raise ValueError("V too small")
        elif abs(V) > (2 * abs(qf - q0) / tf):
            raise ValueError("V too big")
    
    vel_max = V

    if q0 == qf: # if the joint is stationary
        return (np.full(len(time), q0), np.zeros(len(time)), np.zeros(len(time))) # return q = q0, qd = 0, and qdd = 0 for the entire trajectory time
    else:
        a_accel_rand = (vel_max / t_accel_rand) # random acceleration, dependent on t_accel_rand generated by HKA
        t_brake_rand = 2 * (qf - q0) / vel_max + t_accel_rand - tf # the corresponding brake time
        a_brake_rand = vel_max / (tf - t_brake_rand) # the corresponding decceleration

        for tk in time: # the following trajectory planning is formulated according to the tools.trapezoidal method in roboticstoolbox
            if tk < 0:
                qk = q0
                qdk = 0
                qddk = 0
            elif tk <= t_accel_rand:
                qk = q0 + 0.5 * a_accel_rand * tk**2
                qdk = a_accel_rand * tk
                qddk = a_accel_rand
            elif tk <= t_brake_rand:
                qk = q0 + 0.5 * a_accel_rand * t_accel_rand**2 + vel_max * (tk - t_accel_rand)
                qk = vel_max * tk + q0 + 0.5 * a_accel_rand * t_accel_rand**2 - vel_max * t_accel_rand
                qdk = vel_max
                qddk = 0
            elif tk <= tf:
                qk = q0 + 0.5 * a_accel_rand * t_accel_rand**2 + vel_max * (t_brake_rand - t_accel_rand) + (vel_max * (tk - t_brake_rand) - 0.5 * a_brake_rand * (tk - t_brake_rand)**2)
                qdk = vel_max - a_brake_rand * (tk - t_brake_rand)
                qddk = -a_brake_rand
            else:
                qk = qf
                qdk = 0
                qddk = 0

            q.append(qk)
            qd.append(qdk)
            qdd.append(qddk)

        return (np.array(q), np.array(qd), np.array(qdd))

def hka_profile_opt(N, Nbest, traj):
    """
    Randomly generate a set of trajectories and optimize for a most energy-efficient solution.
    Outputs the covariance matrix after each optimization iteration.
    Outputs the original and optimized energy consumption.
    Outputs algorithm runtime.
    Stores the optimized trajectory in prof_result_q.txt, prof_result_qd.txt and prof_result_qdd.txt, 

    :param N: size of the random trajectory set to be evaluated by HKA, 20 <= N <= 50 for optimal performance
    :param Nbest: the number of best sets of trajectory (i.e. Nbest candidates) to be considered by HKA
    :traj: original trajectory generated by tools.trapezoidal in roboticstoolbox
    :return result_q: the optimized angular trajectory
    :return result_qd: the optimized velocity trajectory
    :return result_qdd: the optimized acceleration trajectory
    """
    start_time = ti.time() # timer that records algorithm runtime
    vel_max = np.zeros(6)
    a = np.zeros(6)
    t_accel = np.zeros(6) 
    t_brake = np.zeros(6)
    t_min = np.zeros(6) # initialize minimal acceleration time, will later be derived from boundary conditions
    t_max = np.zeros(6) # initialize maximal acceleration time, will later be derived from boundary conditions
    plot_trajectory(traj) # plot trajectory
    time = traj[6]
    step = traj[7] # total time step of the trajectory
    angle = np.zeros((6, step)) 
    velocity = np.zeros((6, step))
    accel = np.zeros((6, step))
    t0 = 0 # start
    tf = time[-1] # finish
    mu_t = np.zeros(6) # mean vector for Kalman
    sig_t =  np.zeros(6) # covariance vector for Kalman
    t_accel_rand = np.zeros((6, N)) # the matrix to store all N randomly generated acceleration time vectors for all 6 joints, hence the size 6 x N
    q0 = np.zeros(6)
    qf = np.zeros(6)
    q_mat = np.zeros((N, 6, step)) # matrix to store randomly generated angular trajectories of all 6 joints, N trajectories in total, hence the size N x 6 x step
    qd_mat = np.zeros((N, 6, step)) # randomly generated velocity trajectory
    qdd_mat = np.zeros((N, 6, step)) # randomly generated acceleration trajectory
    iter = 0 # iteration counter
    post_t_rand = np.zeros((6, Nbest)) # matrix to store the Nbest acceleration time vectors that yield the best energy efficiency

    for j in range(6): # reads necessary data from the original trajectory
        angle[j, :] = traj[j].q
        velocity[j, :] = traj[j].qd
        accel[j, :] = traj[j].qdd
        q0[j] = angle[j, 0]
        qf[j] = angle[j, -1]

        if q0[j] == qf[j]: # if the joint does not move originally, then prevent the optimizer from moving it during optimization
            vel_max[j] = 0
            t_accel[j] = 0
            t_brake[j] = tf
            a[j] = 0
            t_min[j] = abs(vel_max[j] / 200)
            t_max[j] = abs(tf / 3 + vel_max[j] / 200)
        else: 
            vel_max[j] = (qf[j] - q0[j]) / tf * 1.5 
            t_accel[j] = np.round((q0[j] - qf[j] + vel_max[j] * tf) / vel_max[j], 2) # end of acceleration, rounded to 2 decimals to exactly match the time points in traj[6]
            t_brake[j] = np.round(tf - t_accel[j], 2) # start of braking
            a[j] = vel_max[j] / t_accel[j]
            t_min[j] = abs(vel_max[j] / 100) # boundary condition: maximal angular acceleration 250 s^-2
            t_max[j] = abs(tf - tf / 3 - vel_max[j] / 100) # maximal allowed acceleration time is reached when the joint has to brake with the maximal angular acceleration in order to reach end configuration (250 s^-2)

    mu_t = t_accel # initialize mean vector
    sig_t = (t_max - t_min) / 2 # initialize std.dev.vector
    q_torq_og = np.transpose(angle) # transpose the matrix to be read by calculate_energy()
    qd_torq_og = np.transpose(velocity)
    qdd_torq_og = np.transpose(accel)
    en_og = calculate_energy(q_torq_og, qd_torq_og, qdd_torq_og, time) # see energy_est.py
    print(f'original total energy consumption: {en_og} J')

    # HKA starts here
    while iter <= 150:

        for j in range(6): # generate truncated gaussian distribution to account for boundary conditions
            lb = (t_min[j] - mu_t[j]) / sig_t[j]
            ub = (t_max[j] - mu_t[j]) / sig_t[j]
            trunc_gen_t = truncnorm(lb, ub, loc=mu_t[j], scale=sig_t[j]) 
            t_accel_rand[j, :] = trunc_gen_t.rvs(size=N) # truncated gaussian distribution of size N is stored here
  
        energy_list_def = [('Energy','f8'), ('Number','i2')] # define a tuple that contains the energy consumption and the corresponding row index
        energy_list = np.zeros((N), dtype = energy_list_def) # initialize tuple

        for i in range(N): # iterate through trajectory set
            for j in range(6): # iterate through each joint
                max_velocity = vel_max[j]
                t_accel_r = t_accel_rand[j, i]
                q0_r = q0[j]
                qf_r = qf[j] 
                tg = gen_traj(max_velocity, t_accel_r, q0_r, qf_r, tf, time)
                q_mat[i, j, :] = tg[0]
                qd_mat[i, j, :] = tg[1]
                qdd_mat[i, j, :] = tg[2]

            #To plot search domain
            #if iter == 0:
            #    fig.suptitle(f'Search domain for Joint 1', fontsize=16)
            #    ax1.plot(time, q_mat[i, 0, :])
            #    ax1.set_xlabel('Travel Time in s')
            #    ax1.set_ylabel('Joint angle in rad')
            #    ax2.plot(time, qd_mat[i, 0, :])
            #    ax2.set_xlabel('Travel Time in s')
            #    ax2.set_ylabel('Joint velocity in rad/s')

            q_torq = np.transpose(q_mat[i, :, :]) # transpose to be read by calculate_energy()
            qd_torq = np.transpose(qd_mat[i, :, :])
            qdd_torq = np.transpose(qdd_mat[i, :, :])
            energy_list[i] = (calculate_energy(q_torq, qd_torq, qdd_torq, time), i)

        sorted_energy_list = np.sort(energy_list, order='Energy') # sort energy consumption from lowest to highest
        num_array = sorted_energy_list['Number'] # the corresponding indices
        t_rand_index = num_array[0 : Nbest] # the indices of the Nbest acceleration time vectors
        for j in range(6):
            post_t_rand[j, :] = [t_accel_rand[j, i] for i in t_rand_index] # store accel time vectors into a big matrix to run through HKA
        #print(post_t_rand)
        mu_t_rand = np.mean(post_t_rand, 1) # mean of Nbest candidates
        var_t_rand = np.var(post_t_rand, 1) # variance of Nbest candidates
        new_mu_sig_t = kalman_gain(sig_t, var_t_rand, mu_t, mu_t_rand) # calculate Kalman gain, see HKA_kalman_gain.py
        mu_t = new_mu_sig_t[0] # new mean
        sig_t = new_mu_sig_t[1] # new std.dev.
        print(f'the diagonal of the covariance matrix:\n{var_t_rand}')

        if all(i < 1e-4 for i in var_t_rand) == True: # convergence criterion
            print(f'exited HKA at iter = {iter}')
            break
        
        print(f'End of iteration {iter}, begin iteration {iter+1}\n')
        iter = iter + 1

    # the results delivered by HKA are processed below
    energy_opt = energy_list[num_array[0]] 
    result_q = q_mat[num_array[0], :, :]
    result_qd = qd_mat[num_array[0], :, :]
    result_qdd = qdd_mat[num_array[0], :, :]
    delta_J = en_og - energy_opt[0]
    percent_J = np.round(delta_J / en_og * 100, 1)
    np.savetxt('prof_result_q.txt', result_q)
    np.savetxt('prof_result_qd.txt', result_qd)
    np.savetxt('prof_result_qdd.txt', result_qdd)
    print(f'Original total energy consumption: {en_og} J')
    print(f'Optimized total energy consumption: {energy_opt} J')
    print(f'{delta_J} J (around {percent_J}%) can be saved with the optimized trajectory.')
    print(f'Optimization runtime: {ti.time() - start_time} seconds')
    print(f'Optimized initial acceleration: {result_qdd[:, 0]}')
    return result_q, result_qd, result_qdd

start1 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end1 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start2 = np.array([pi/2, -pi/2, pi/2, -pi/2, -pi/2, 0])
end2 = np.array([pi, -pi, 0, pi/4, -pi/2, pi])

start3 = np.array([0, 0, 0, 0, 0, 0])
end3 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])

start4 = np.array([pi, -pi/2, pi/2, -pi/2, -pi/2, 0])
end4 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start5 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end5 = np.array([2*pi/3, -pi/8, pi, -pi/2, 0, -pi/3])

#end = np.array([-pi, -pi/2, pi/2, -pi/2, -pi/2, 0])
traj = generate_traj_time(2, 201, start1, end1)
hka_profile_opt(30, 4, traj)


decision = 1
if decision == 1:
    for j in range(6):
        result_q = np.loadtxt('prof_result_q.txt')
        result_qd = np.loadtxt('prof_result_qd.txt')
        result_qdd = np.loadtxt('prof_result_qdd.txt')
        joint_data = traj
        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, layout='constrained')
        ax1.plot(joint_data[6], result_q[j, :], label=f'optimized traj for joint {j+1}', color='green')
        ax1.plot(joint_data[6], joint_data[j].q, label=f'orignal traj for joint {j+1}', color='red')
        ax1.set_xlabel('Travel time in s')
        ax1.set_ylabel('Joint angle in rad')
        ax1.legend()
        ax2.plot(joint_data[6], result_qd[j, :], label=f'optimized traj for joint {j+1}', color='g')
        ax2.plot(joint_data[6], joint_data[j].qd, label=f'orignal traj for joint {j+1}', color='r')
        ax2.set_xlabel('Travel time in s')
        ax2.set_ylabel('Joint velocity in rad/s')
        ax3.plot(joint_data[6], result_qdd[j, :], label=f'optimized traj for joint {j+1}', color='g')
        ax3.plot(joint_data[6], joint_data[j].qdd, label=f'orignal traj for joint {j+1}', color='r')
        ax3.set_xlabel('Travel time in s')
        ax3.set_ylabel('Joint acceleration in rad/s^2')
        fig.suptitle(f"Trajectory for Joint {j+1}", fontsize=16)
        
        #fig.savefig(f'C:\Codes\master_thesis\Trajectory\Figures\Profile_optimization/prof_opt_joint{j+1}.png')
        plt.show()
