'''
@author: Shihui Liu

A force-limited trajectory planning method using HKA and velocity profile optimization. Seven contact points are considered. Similar to momentum-limited trajectory planning, the contact force is
considered instead of linear momentum. The contact force is calculated in calculate_max_force(), the procedures are based on ISO/TS 15066. The optimization is based on the velocity profile optimization
method.
'''

from math import pi, sqrt
import roboticstoolbox as rtb
import numpy as np
from traj import generate_traj_time
import matplotlib.pyplot as plt
import time as ti
from scipy.stats import truncnorm
from HKA_kalman_gain import *
import json
from calculate_momentum import *
from utility import *

Yu = rtb.models.DH.Yu()

def calculate_max_force(q_mat, qd_mat, contact_points_table, m_H, K, F_p):
    """
    Calculate the contact force curves of all contact points . Procedures very similar to calculate_momentum.

    :param q_mat: angle trajectories of all robot joints, size: 6x201
    :param qd: velocity trajectories of all robot joints, size: 6x201
    :param contact_points_table: the table of contact points generated by get_contact_points() from utility.py
    :param m_H : the effective mass of the human body region involved in contact
    :param K: the spring constant of the human body region involved in contact
    :param F_p: the maximal permitted contact force of the human body region involved in contact
    :return max_contact_force: the maximal contact force that occurs during the trajectory for each contact point, size: 6x1
    :return max_of_all: the overall maximal contact force among all contact points
    :return delta_f: the difference between max_of_all and maximal permitted contact force, used for computing objective function
    :return index_max_of_all: determine the index of the contact point with overall maximal contact force
    """
    m_refl = np.zeros((7, 201)) # reflected mass
    lin_vel = np.zeros((7, 3, 201)) # linear velocity (vector)
    vel_scalar = np.zeros((7, 201)) # scalar linear velocity
    rf_p_storage = np.zeros((7, 3, 201)) # position vector of contact points for plotting, not used anywhere
    reduced_mass = np.zeros((7, 201)) # reduced mass of the contact point (resulting mass from reflected mass and mass of body region)
    equi_contact_force = np.zeros((7, 201)) # equivalent contact force calculated based on ISO/TS 15066

    for t in range(201):

        q = q_mat[:, t]
        qd = qd_mat[:, t]

        for n, point_list in enumerate(contact_points_table):
            result = calculate_momentum(q, qd, point_list[0], point_list[1])
            lin_vel[n, :, t] = result[2]
            vel_scalar[n, t] = np.linalg.norm(lin_vel[n, :, t], 2)
            m_refl[n, t] = result[1]
            if m_refl[n, t] == 0: # if reflected mass is zero (the point is stationary)
                reduced_mass[n, t] = 0 # set reduced mass to zero, such point is not considered by optimizer
            else:
                reduced_mass[n, t] = 1 / (1 / m_refl[n, t] + 1 / m_H) # calculation of reduced mass, see ISO/TS 15066 and master's thesis
            equi_contact_force[n, t] = vel_scalar[n, t] * sqrt(reduced_mass[n, t] * K) # equivalent contact force, see ISO/TS 15066 and master's thesis
            rf_p_storage[n, :, t] = result[3][:3]

    max_contact_force = np.amax(equi_contact_force, axis=1)
    print(f'The maximal contact forces that occur during the trajectory for each joint are: {max_contact_force} N')
    max_of_all = np.amax(max_contact_force)
    index_max_of_all = np.argmax(max_contact_force)
    print(f'Overall maximal contact force is calculated to be at contact point {index_max_of_all+1} N')
    delta_f = (max_of_all - F_p)**2 # objective function

    return max_contact_force, max_of_all, delta_f, index_max_of_all

def hka_force_opt(N, Nbest, trajectory_data):
    """
    Randomly generate a set of trajectories and optimize the maximal contact force among all contact points.
    Stores the optimized trajectory in force_result_q.txt (and _qd, _qdd), stores the change of momentum after each HKA iteration in post_mean_momentum.txt
    
    :param N: size of the random trajectory set to be evaluated by HKA
    :param Nbest: the number of best sets of trajectory (i.e. Nbest candidates) to be considered by HKA
    :param trajectory_data: original trajectory obtained by get_original_jointdata
    :return result_q: the optimized angular trajectory
    :return result_qd: the optimized velocity trajectory
    :return result_qdd: the optimized acceleration trajectory
    """
    start_time = ti.time() # timer that records algorithm runtime
    vel_max = np.zeros(6)
    a = np.zeros(6)
    t_accel = np.zeros(6) 
    t_brake = np.zeros(6)
    t_min = np.zeros(6) # initialize minimal acceleration time, will later be derived from boundary conditions
    t_max = np.zeros(6) # initialize maximal acceleration time, will later be derived from boundary conditions
    #plot_trajectory(traj) # plot trajectory
    time = trajectory_data[6]
    step = trajectory_data[7] # total time step of the trajectory
    t0 = 0 # start
    tf = time[-1] # finish
    mu_t = np.zeros(6) # mean vector for Kalman
    sig_t =  np.zeros(6) # covariance vector for Kalman
    t_accel_rand = np.zeros((6, N)) # the matrix to store all N randomly generated acceleration time vectors for all 6 joints, hence the size 6 x N
    q0 = np.zeros(6)
    qf = np.zeros(6)
    q_mat = np.zeros((N, 6, step)) # matrix to store randomly generated angular trajectories of all 6 joints, N trajectories in total, hence the size N x 6 x step
    qd_mat = np.zeros((N, 6, step)) # randomly generated velocity trajectory
    qdd_mat = np.zeros((N, 6, step)) # randomly generated acceleration trajectory
    iter = 0 # iteration counter
    post_t_rand = np.zeros((6, Nbest)) # matrix to store the Nbest acceleration time vectors that yield the best energy efficiency

    contact_points_table = get_contact_points()
    original_jointdata =  get_original_jointdata(trajectory_data)
    angle = original_jointdata[0]
    velocity = original_jointdata[1]
    accel = original_jointdata[2]
    q0 = original_jointdata[4]
    qf = original_jointdata[5]
    K = 35000 # Shoulder is smashed against the robot, ouch!
    F_p = 210 # Shoulder is smashed against the robot, ouch!
    m_H = 40 # Shoulder is smashed against the robot, ouch!
    post_mean_force = []

    for j in range(6): # reads necessary data from the original trajectory
        angle[j, :] = trajectory_data[j].q
        velocity[j, :] = trajectory_data[j].qd
        accel[j, :] = trajectory_data[j].qdd
        q0[j] = angle[j, 0]
        qf[j] = angle[j, -1]

    original_data = calculate_max_force(angle, velocity, contact_points_table, m_H, K, F_p)
    original_force = original_data[1]
    max_force_point = original_data[3]

    if original_force < F_p:
        print(f'max force is {original_force} N at Point {max_force_point+1}, trajectory is safe, no optimization need!')
        return
    else:
        print(f'max force is {original_force} N at Point {max_force_point+1}, optimization is needed')

    for j in range(6): 

        if q0[j] == qf[j]: # if the joint does not move originally, then prevent the optimizer from moving it during optimization
            vel_max[j] = 0
            t_accel[j] = 0
            t_brake[j] = tf
            a[j] = 0
            t_min[j] = abs(vel_max[j] / 100)
            t_max[j] = abs(tf / 3 + vel_max[j] / 100)

        #elif j == 0:
        #    vel_max[j] = 10
        #    t_accel[j] = np.round((q0[j] - qf[j] + vel_max[j] * tf) / vel_max[j], 2) # end of acceleration, rounded to 2 decimals to exactly match the time points in traj[6]
        #    t_brake[j] = np.round(tf - t_accel[j], 2) # start of braking
        #    a[j] = vel_max[j] / t_accel[j]
        #    t_min[j] = abs(vel_max[j] / 100) # boundary condition: maximal angular acceleration 250 s^-2
        #    print(t_min[j])
        #    t_max[j] = abs(tf - tf / 3 - vel_max[j] / 100) # maximal allowed acceleration time is reached when the joint has to brake with the maximal angular acceleration in order to reach end configuration (250 s^-2)
        #    print(t_max[j])
        else:
            vel_max[j] = (qf[j] - q0[j]) / tf * 1.5 
            t_accel[j] = np.round((q0[j] - qf[j] + vel_max[j] * tf) / vel_max[j], 2) # end of acceleration, rounded to 2 decimals to exactly match the time points in traj[6]
            t_brake[j] = np.round(tf - t_accel[j], 2) # start of braking
            a[j] = vel_max[j] / t_accel[j]
            t_min[j] = abs(vel_max[j] / 100) # boundary condition: maximal angular acceleration 250 s^-2
            t_max[j] = abs(tf - tf / 3 - vel_max[j] / 100) # maximal allowed acceleration time is reached when the joint has to brake with the maximal angular acceleration in order to reach end configuration (250 s^-2)

    mu_t = t_accel # initialize mean vector
    sig_t = (t_max - t_min) / 2 # initialize std.dev.vector
    while iter <= 20:

        for j in range(6): # generate truncated gaussian distribution to account for boundary conditions
            lb = (t_min[j] - mu_t[j]) / sig_t[j]
            ub = (t_max[j] - mu_t[j]) / sig_t[j]
            trunc_gen_t = truncnorm(lb, ub, loc=mu_t[j], scale=sig_t[j]) 
            t_accel_rand[j, :] = trunc_gen_t.rvs(size=N) # truncated gaussian distribution of size N is stored here
          
        contact_force_list_def = [('Force','f8'), ('Number','i2'), ('Force Diff', 'f8'), ('index', 'i2')] # define a tuple that contains the energy consumption and the corresponding row index
        contact_force_list = np.zeros(N, dtype = contact_force_list_def) # initialize tuple

        for i in range(N): # iterate through trajectory set
            for j in range(6): # iterate through each joint
                max_velocity = vel_max[j]
                t_accel_r = t_accel_rand[j, i]
                q0_r = q0[j]
                qf_r = qf[j] 
                tg = gen_traj(max_velocity, t_accel_r, q0_r, qf_r, tf, time)
                q_mat[i, j, :] = tg[0]
                qd_mat[i, j, :] = tg[1]

            force_data = calculate_max_force(q_mat[i, :, :], qd_mat[i, :, :], contact_points_table, m_H, K, F_p)
            max_contact_force = force_data[0]
            max_of_all = force_data[1]
            delta_f = force_data[2]
            index_max = force_data[3]
            contact_force_list[i] = (max_of_all, i, delta_f, index_max)
            print(contact_force_list)
            print(f'finished computation of set no. {i+1}')
         
        sorted_force_list = np.sort(contact_force_list, order='Force Diff') # sort energy consumption from lowest to highest
        #print(sorted_force_list)
        num_array = sorted_force_list['Number'] # the corresponding indices
        t_rand_index = num_array[0 : Nbest] # the indices of the Nbest acceleration time vectors
        post_mean_force.append(np.mean(sorted_force_list[0][0]))
        #momentum_history.append(momentum_per_iter.tolist())

        for j in range(6):
            post_t_rand[j, :] = [t_accel_rand[j, i] for i in t_rand_index] # store accel time vectors into a big matrix to run through HKA
        #print(post_t_rand)

        mu_t_rand = np.mean(post_t_rand, 1) # mean of Nbest candidates
        var_t_rand = np.var(post_t_rand, 1) # variance of Nbest candidates
        new_mu_sig_t = kalman_gain(sig_t, var_t_rand, mu_t, mu_t_rand) # calculate Kalman gain, see HKA_kalman_gain.py
        mu_t = new_mu_sig_t[0] # new mean
        sig_t = new_mu_sig_t[1] # new std.dev.
        print(f'the diagonal of the covariance matrix:\n{var_t_rand}')

        if (all(i < 1e-4 for i in var_t_rand) == True): # convergence criterion
            print(f'exited HKA at iter = {iter}')
            break
        
        print(f'End of iteration {iter}, begin iteration {iter+1}\n')
        iter = iter + 1
            #To plot search domain
            #if iter == 0:
            #    fig.suptitle(f'Search domain for Joint 1', fontsize=16)
            #    ax1.plot(time, q_mat[i, 0, :])
            #    ax1.set_xlabel('Travel Time in s')
            #    ax1.set_ylabel('Joint angle in rad')
            #    ax2.plot(time, qd_mat[i, 0, :])
            #    ax2.set_xlabel('Travel Time in s')
            #    ax2.set_ylabel('Joint velocity in rad/s')

    force_opt = contact_force_list[num_array[0]] 
    result_q = q_mat[num_array[0], :, :]
    result_qd = qd_mat[num_array[0], :, :]
    result_qdd = qdd_mat[num_array[0], :, :]
    #np.savetxt('force_result_q.txt', result_q)
    #np.savetxt('force_result_qd.txt', result_qd)
    #np.savetxt('force_result_qdd.txt', result_qdd)
    np.savetxt('mean_force.txt', post_mean_force)

    #with open('momentum_history.json', 'w') as file:
    #    json.dump(momentum_history, file)

    print(f'Original max contact force: ')
    print(f'Optimized total energy consumption: {force_opt} J')
    print(f'Optimization runtime: {ti.time() - start_time} seconds')
    print(f'Optimized initial acceleration: {result_qdd[:, 0]}')
    return result_q, result_qd, result_qdd   

start0 = np.array([0, 0, 0, 0, 0, 0])
end0 = np.array([-pi/2, 0, 0, -0, -0, 0])    

start1 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end1 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start2 = np.array([pi/2, -pi/2, pi/2, -pi/2, -pi/2, 0])
end2 = np.array([pi, -pi, 0, pi/4, -pi/2, pi])

start3 = np.array([0, 0, 0, 0, 0, 0])
end3 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])

start4 = np.array([pi, -pi/2, pi/2, -pi/2, -pi/2, 0])
end4 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start5 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end5 = np.array([2*pi/3, -pi/8, pi, -pi/2, 0, -pi/3])

trajectory_data = generate_traj_time(2, 201, start1, end1)

hka_force_opt(10, 4, trajectory_data)
"""
n = 6
m_refl[n, 0] = m_refl[n, 1]
m_refl[n, -1] = m_refl[n, -2]
print(f'Reflected mass: \n{m_refl[n, :]}')
#print(lin_vel[n, :, :])
vel_abs = np.linalg.norm(lin_vel[n, :, :], axis=0)

#print(vel_abs)
refl_max = np.argmax(m_refl[n, :])
#print(refl_max)
#print(m_refl[n, refl_max])
momentum = np.multiply(vel_abs, m_refl[n, :])
print(f'Momentum trajectory: \n{momentum}')
#ax = plt.axes(111, projection='3d')
print(vel_abs)

lin_vel_plot = lin_vel[n, :, :]
start = np.transpose(rf_p_storage[n, :, :])
#print(rf_p_storage[n, :, :])
xline2 = start[:, 0]
yline2 = start[:, 1]
zline2 = start[:, 2]


Yu = rtb.models.DH.Yu()
start1 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end1 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start2 = np.array([pi/2, -pi/2, pi/2, -pi/2, -pi/2, 0])
end2 = np.array([pi, -pi, 0, pi/4, -pi/2, pi])

start3 = np.array([0, 0, 0, 0, 0, 0])
end3 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])

start4 = np.array([pi, -pi/2, pi/2, -pi/2, -pi/2, 0])
end4 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start5 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end5 = np.array([2*pi/3, -pi/8, pi, -pi/2, 0, -pi/3])
trajectory_data = generate_traj_time(2, 201, start1, end1)
"""
"""
ax = plt.axes(111, projection='3d')
#ax.set_xlim([-8, 8])
#ax.set_ylim([-8, 8])
#ax.set_zlim([-1, 1])
#ax.set_xlim(0, 1)
#ax.set_ylim(0, 1)
#ax.set_zlim(0, 1)
#ax.set_aspect('equal', adjustable='box')
ax.axis('scaled')
ax.set_xlabel('x coordinate in m')
ax.set_ylabel('Y coordinate in m')
ax.set_zlabel('Z coordinate in m')
#ax.plot3D(xline, yline, zline)
#ax.plot3D(xline1, yline1, zline1, color='blue')
ax.plot3D(xline2, yline2, zline2, color='red', linewidth=1, label='Trajectory of center of mass')
"""
"""
for i in range(201):
#for i in range(5):
    if i == 0:
        ax.quiver(start[i, 0], start[i, 1], start[i, 2], lin_vel_plot[0, i], lin_vel_plot[1, i], lin_vel_plot[2, i], length=0.4*np.linalg.norm((start[i, :]-lin_vel_plot[:, i]), 2), arrow_length_ratio=0.05, normalize='false', color='green', label='Momentum vector of robot on its center of mass')
    elif i % 4 == 0:
    #ax.quiver(start[i, 0], start[i, 1], start[i, 2], lin_max[i, 0], lin_max[i, 1], lin_max[i, 2], arrow_length_ratio=0.01, length=np.linalg.norm((start[i, :]-lin_max[i, :]), 2), normalize='True')
        ax.quiver(start[i, 0], start[i, 1], start[i, 2], lin_vel_plot[0, i], lin_vel_plot[1, i], lin_vel_plot[2, i], length=0.4*np.linalg.norm((start[i, :]-lin_vel_plot[:, i]), 2), arrow_length_ratio=0.05, normalize='false', color='green')#length=0.01*np.linalg.norm((start[i, :]-lin_max[i, :]), 2), normalize='True', arrow_length_ratio=0.05, color='blue')
    #ax.quiver(T_cm[i, 0], T_cm[i, 1], T_cm[i, 2], lin_max[i, 0], lin_max[i, 1], lin_max[i, 2], arrow_length_ratio=0.01, length=np.linalg.norm((start[i, :]-lin_max[i, :]), 2), normalize='True')
#plt.show()
#ax.legend()
#plt.show()
"""

"""
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.plot(traj[6], momentum)
ax1.set_xlabel('Travel Time in s')
ax1.set_ylabel('momentum in kg*m/s')

ax2.plot(traj[6], m_refl[n, :])
ax2.set_xlabel('Travel Time in s')
ax2.set_ylabel('reflected mass in kg')
ax2.set_ylim([0, 5])
plt.show()
"""