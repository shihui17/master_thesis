'''
@author: Shihui Liu

Use gen_traj() to generate trapezoidal trajectories given parameters generated by HKA
Use hka_profile_opt() to optimize robot energy consumption given a set of randomly generated trapezoidal trajectories using HKA
Uncomment the last section of the code to visualize the trajectories in joint space.
'''

from math import pi
import numpy as np
from roboticstoolbox import tools as tools
import matplotlib.pyplot as plt
from call_tau import *
from scipy.stats import truncnorm
from plot_traj import *
from traj import *
from HKA_kalman_gain import *
from energy_est import *
import time as ti

def hka_profile_opt(N, Nbest, traj, start_joint_config, end_joint_config):
    """
    Randomly generate a set of trajectories and optimize for a most energy-efficient solution.
    Outputs the covariance matrix after each optimization iteration.
    Outputs the original and optimized energy consumption.
    Outputs algorithm runtime.
    Stores the optimized trajectory in prof_result_q.txt, prof_result_qd.txt and prof_result_qdd.txt, 

    :param N: size of the random trajectory set to be evaluated by HKA, 20 <= N <= 50 for optimal performance
    :param Nbest: the number of best sets of trajectory (i.e. Nbest candidates) to be considered by HKA
    :traj: original trajectory generated by tools.trapezoidal in roboticstoolbox
    :return result_q: the optimized angular trajectory
    :return result_qd: the optimized velocity trajectory
    :return result_qdd: the optimized acceleration trajectory
    """
    start_time = ti.time() # timer that records algorithm runtime
    plot_trajectory(traj) # plot trajectory
    time = traj[6]
    step = traj[7] # total time step of the trajectory
    angle = np.zeros((6, step)) 
    velocity = np.zeros((6, step))
    accel = np.zeros((6, step))
    t0 = 0 # start
    tf = time[-1] # finish
    t_min = 0.8*tf
    t_max = 1.2*tf
    mu_t = np.zeros(6) # mean vector for Kalman
    sig_t =  np.zeros(6) # covariance vector for Kalman
    tf_rand = np.zeros(N) # the matrix to store all N randomly generated acceleration time vectors for all 6 joints, hence the size 6 x N
    q0 = np.zeros(6)
    qf = np.zeros(6)
    q_mat = np.zeros((N, 6, step)) # matrix to store randomly generated angular trajectories of all 6 joints, N trajectories in total, hence the size N x 6 x step
    qd_mat = np.zeros((N, 6, step)) # randomly generated velocity trajectory
    qdd_mat = np.zeros((N, 6, step)) # randomly generated acceleration trajectory
    iter = 0 # iteration counter
    post_t_rand = np.zeros((6, Nbest)) # matrix to store the Nbest acceleration time vectors that yield the best energy efficiency
    tf_r = np.zeros(6)
    flag = np.full(6, False)

    for j in range(6): # reads necessary data from the original trajectory
        angle[j, :] = traj[j].q
        velocity[j, :] = traj[j].qd
        accel[j, :] = traj[j].qdd
        q0[j] = angle[j, 0]
        qf[j] = angle[j, -1]

        if q0[j] == qf[j]: # if the joint does not move originally, then prevent the optimizer from moving it during optimization
            flag[j] = True
    
    mu_t = tf
    sig_t = (t_max - t_min) / 2 # initialize std.dev.vector
    q_torq_og = np.transpose(angle) # transpose the matrix to be read by calculate_energy()
    qd_torq_og = np.transpose(velocity)
    qdd_torq_og = np.transpose(accel)
    en_og = calculate_energy(q_torq_og, qd_torq_og, qdd_torq_og, time) # see energy_est.py
    print(f'original total energy consumption: {en_og} J')

    # HKA starts here
    while iter <= 150:

        lb = (t_min - mu_t) / sig_t
        ub = (t_max - mu_t) / sig_t
        trunc_gen_t = truncnorm(lb, ub, loc=mu_t, scale=sig_t) 
        tf_rand = trunc_gen_t.rvs(size=N) # truncated gaussian distribution of size N is stored here
  
        energy_list_def = [('Energy','f8'), ('Number','i2')] # define a tuple that contains the energy consumption and the corresponding row index
        energy_list = np.zeros((N), dtype = energy_list_def) # initialize tuple

        for i in range(N): # iterate through trajectory set
            tg = generate_traj_time(tf_rand[i], step, start_joint_config, end_joint_config)
            for j in range(6):
                if flag[j] == False:
                    q_mat[i, j, :] = tg[j].q
                    qd_mat[i, j, :] = tg[j].qd
                    qdd_mat[i, j, :] = tg[j].qdd
                else:
                    q_mat[i, j, :] = angle[j, :]
                    qd_mat[i, j, :] = velocity[j, :]
                    qdd_mat[i, j, :] = accel[j, :]

            #To plot search domain
            #if iter == 0:
            #    fig.suptitle(f'Search domain for Joint 1', fontsize=16)
            #    ax1.plot(time, q_mat[i, 0, :])
            #    ax1.set_xlabel('Travel Time in s')
            #    ax1.set_ylabel('Joint angle in rad')
            #    ax2.plot(time, qd_mat[i, 0, :])
            #    ax2.set_xlabel('Travel Time in s')
            #    ax2.set_ylabel('Joint velocity in rad/s')

            q_torq = np.transpose(q_mat[i, :, :]) # transpose to be read by calculate_energy()
            qd_torq = np.transpose(qd_mat[i, :, :])
            qdd_torq = np.transpose(qdd_mat[i, :, :])
            energy_list[i] = (calculate_energy(q_torq, qd_torq, qdd_torq, time), i)

        sorted_energy_list = np.sort(energy_list, order='Energy') # sort energy consumption from lowest to highest
        num_array = sorted_energy_list['Number'] # the corresponding indices
        t_rand_index = num_array[0 : Nbest] # the indices of the Nbest acceleration time vectors
        post_t_rand = [tf_rand[i] for i in t_rand_index] # store accel time vectors into a big matrix to run through HKA
        #print(post_t_rand)
        mu_t_rand = np.mean(post_t_rand) # mean of Nbest candidates
        var_t_rand = np.var(post_t_rand) # variance of Nbest candidates
        new_mu_sig_t = kalman_gain(sig_t, var_t_rand, mu_t, mu_t_rand) # calculate Kalman gain, see HKA_kalman_gain.py
        mu_t = new_mu_sig_t[0] # new mean
        sig_t = new_mu_sig_t[1] # new std.dev.
        print(f'the diagonal of the covariance matrix:\n{var_t_rand}')

        if var_t_rand < 1e-4: # convergence criterion
            print(f'exited HKA at iter = {iter}')
            break
        
        print(f'End of iteration {iter}, begin iteration {iter+1}\n')
        iter = iter + 1

    # the results delivered by HKA are processed below
    energy_opt = energy_list[num_array[0]] 
    result_q = q_mat[num_array[0], :, :]
    result_qd = qd_mat[num_array[0], :, :]
    result_qdd = qdd_mat[num_array[0], :, :]
    delta_J = en_og - energy_opt[0]
    percent_J = np.round(delta_J / en_og * 100, 1)
    optimized_time = np.linspace(0, mu_t, step)
    np.savetxt('trajtime_result_q.txt', result_q)
    np.savetxt('trajtime_result_qd.txt', result_qd)
    np.savetxt('trajtime_result_qdd.txt', result_qdd)
    print(f'Original total energy consumption: {en_og} J')
    print(f'Optimized total energy consumption: {energy_opt} J')
    print(f'{delta_J} J (around {percent_J}%) can be saved with the optimized trajectory.')
    print(f'Optimization runtime: {ti.time() - start_time} seconds')
    return result_q, result_qd, result_qdd, optimized_time

start = np.array([-1.570796327,	-1.570796327,	1.570796327,	-1.570796327,	-1.570796327,	0])
end = np.array([1.215785543,	-1.319583654,	0.625792825,	-2.292949242,	-1.57085216,	-0.000166897])

start1 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end1 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start2 = np.array([pi/2, -pi/2, pi/2, -pi/2, -pi/2, 0])
end2 = np.array([pi, -pi, 0, pi/4, -pi/2, pi])

start3 = np.array([0, 0, 0, 0, 0, 0])
end3 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])

start4 = np.array([pi, -pi/2, pi/2, -pi/2, -pi/2, 0])
end4 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start5 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end5 = np.array([2*pi/3, -pi/8, pi, -pi/2, 0, -pi/3])
#end = np.array([-pi, -pi/2, pi/2, -pi/2, -pi/2, 0])
traj = generate_traj_time(2, 201, start, end)
tg = hka_profile_opt(30, 4, traj, start, end)

optimized_time = tg[3]
np.savetxt("optimized_time_vec.txt", optimized_time)
#print(optimized_time)


decision = 1
if decision == 1:
    joint_data = traj
    for j in range(6):
        result_q = np.loadtxt('trajtime_result_q.txt')
        result_qd = np.loadtxt('trajtime_result_qd.txt')
        result_qdd = np.loadtxt('trajtime_result_qdd.txt')
        fig, (ax1, ax2, ax3) = plt.subplots(3, 1)
        ax1.plot(optimized_time, result_q[j, :], label=f'optimized traj for joint {j+1}', color='green')
        ax1.plot(joint_data[6], joint_data[j].q, label=f'orignal traj for joint {j+1}', color='red')
        ax1.set_xlabel('Travel time in s')
        ax1.set_ylabel('Joint angle in rad')
        ax1.legend()
        ax2.plot(optimized_time, result_qd[j, :], label=f'optimized traj for joint {j+1}', color='g')
        ax2.plot(joint_data[6], joint_data[j].qd, label=f'orignal traj for joint {j+1}', color='r')
        ax2.set_xlabel('Travel time in s')
        ax2.set_ylabel('Joint velocity in rad/s')
        ax3.plot(optimized_time, result_qdd[j, :], label=f'optimized traj for joint {j+1}', color='g')
        ax3.plot(joint_data[6], joint_data[j].qdd, label=f'orignal traj for joint {j+1}', color='r')
        ax3.set_xlabel('Travel time in s')
        ax3.set_ylabel('Joint acceleration in rad/s^2')
        fig.suptitle(f"Trajectory for Joint {j+1}", fontsize=16)
        
        #fig.savefig(f'C:\Codes\master_thesis\Trajectory\Figures\Profile_optimization/prof_opt_joint{j+1}.png')
        plt.show()
