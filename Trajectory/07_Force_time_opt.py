'''
@author: Shihui Liu

A force-limited trajectory planning method using HKA and velocity profile optimization. Seven contact points are considered. Similar to momentum-limited trajectory planning, the contact force is
considered instead of linear momentum. The contact force is calculated in calculate_max_force() (see utility.py), the procedures are based on ISO/TS 15066. The optimization is based on the velocity profile optimization
method.
'''

from math import pi, sqrt
import roboticstoolbox as rtb
import numpy as np
from traj import generate_traj_time
import matplotlib.pyplot as plt
import time as ti
from scipy.stats import truncnorm
from HKA_kalman_gain import *
from calculate_momentum import *
from utility import *

Yu = rtb.models.DH.Yu()

def calculate_max_force(q_mat, qd_mat, contact_points_table, m_H, K, F_p):
    """
    Calculate the contact force curves of all contact points . Procedures very similar to calculate_momentum.

    :param q_mat: angle trajectories of all robot joints, size: 6x201
    :param qd: velocity trajectories of all robot joints, size: 6x201
    :param contact_points_table: the table of contact points generated by get_contact_points() from utility.py
    :param m_H : the effective mass of the human body region involved in contact
    :param K: the spring constant of the human body region involved in contact
    :param F_p: the maximal permitted contact force of the human body region involved in contact
    :return max_contact_force: the maximal contact force that occurs during the trajectory for each contact point, size: 6x1
    :return max_of_all: the overall maximal contact force among all contact points
    :return delta_f: the difference between max_of_all and maximal permitted contact force, used for computing objective function
    :return index_max_of_all: determine the index of the contact point with overall maximal contact force
    """
    m_refl = np.zeros((7, 201)) # reflected mass
    lin_vel = np.zeros((7, 3, 201)) # linear velocity (vector)
    vel_scalar = np.zeros((7, 201)) # scalar linear velocity
    rf_p_storage = np.zeros((7, 3, 201)) # position vector of contact points for plotting, not used anywhere
    reduced_mass = np.zeros((7, 201)) # reduced mass of the contact point (resulting mass from reflected mass and mass of body region)
    equi_contact_force = np.zeros((7, 201)) # equivalent contact force calculated based on ISO/TS 15066

    for t in range(201):

        q = q_mat[:, t]
        qd = qd_mat[:, t]

        for n, point_list in enumerate(contact_points_table):
            result = calculate_momentum(q, qd, point_list[0], point_list[1])
            lin_vel[n, :, t] = result[2]
            vel_scalar[n, t] = np.linalg.norm(lin_vel[n, :, t], 2)
            m_refl[n, t] = result[1]
            if m_refl[n, t] == 0: # if reflected mass is zero (the point is stationary)
                reduced_mass[n, t] = 0 # set reduced mass to zero, such point is not considered by optimizer
            else:
                reduced_mass[n, t] = 1 / (1 / m_refl[n, t] + 1 / m_H) # calculation of reduced mass, see ISO/TS 15066 and master's thesis
            equi_contact_force[n, t] = vel_scalar[n, t] * sqrt(reduced_mass[n, t] * K) # equivalent contact force, see ISO/TS 15066 and master's thesis
            rf_p_storage[n, :, t] = result[3][:3]

    max_contact_force = np.amax(equi_contact_force, axis=1)
    print(f'The maximal contact forces that occur during the trajectory for each joint are: {max_contact_force} N')
    max_of_all = np.amax(max_contact_force)
    index_max_of_all = np.argmax(max_contact_force)
    print(f'Overall maximal contact force is calculated to be at contact point {index_max_of_all+1}')
    delta_f = (max_of_all - F_p)**2 # objective function

    return max_contact_force, max_of_all, delta_f, index_max_of_all

def hka_force_opt(N, Nbest, trajectory_data, start_joint_config, end_joint_config):
    """
    Randomly generate a set of trajectories and optimize for a most energy-efficient solution.
    Outputs the covariance matrix after each optimization iteration.
    Outputs the original and optimized energy consumption.
    Outputs algorithm runtime.
    Stores the optimized trajectory in prof_result_q.txt, prof_result_qd.txt and prof_result_qdd.txt, 

    :param N: size of the random trajectory set to be evaluated by HKA, 20 <= N <= 50 for optimal performance
    :param Nbest: the number of best sets of trajectory (i.e. Nbest candidates) to be considered by HKA
    :traj: original trajectory generated by tools.trapezoidal in roboticstoolbox
    :return result_q: the optimized angular trajectory
    :return result_qd: the optimized velocity trajectory
    :return result_qdd: the optimized acceleration trajectory
    """
    post_mean_force = []
    start_time = ti.time() # timer that records algorithm runtime
    t_min = np.zeros(6) # initialize minimal acceleration time, will later be derived from boundary conditions
    t_max = np.zeros(6) # initialize maximal acceleration time, will later be derived from boundary conditions
    #plot_trajectory(traj) # plot trajectory
    time = trajectory_data[6]
    step = trajectory_data[7] # total time step of the trajectory
    tf = time[-1] # finish
    t_min = 1 * tf # search domain for trajectory time
    t_max = 4 * tf # search domain for trajectory time
    mu_t = np.zeros(6) # mean vector for Kalman
    sig_t =  np.zeros(6) # covariance vector for Kalman
    q0 = np.zeros(6)
    qf = np.zeros(6)
    q_mat = np.zeros((N, 6, step)) # matrix to store randomly generated angular trajectories of all 6 joints, N trajectories in total, hence the size N x 6 x step
    qd_mat = np.zeros((N, 6, step)) # randomly generated velocity trajectory
    qdd_mat = np.zeros((N, 6, step)) # randomly generated acceleration trajectory
    iter = 0 # iteration counter
    post_t_rand = np.zeros((6, Nbest)) # matrix to store the Nbest acceleration time vectors that yield the best energy efficiency
    tf_rand = np.zeros(N)
    contact_points_table = get_contact_points()
    original_jointdata =  get_original_jointdata(trajectory_data)
    angle = original_jointdata[0]
    velocity = original_jointdata[1]
    accel = original_jointdata[2]
    q0 = original_jointdata[4]
    qf = original_jointdata[5]
    flag = np.full(6, False)
        
    K = 35000 # Shoulder is smashed against the robot, ouch!
    F_p = 210 # Shoulder is smashed against the robot, ouch!
    m_H = 40 # Shoulder is smashed against the robot, ouch!

    for j in range(6): # reads necessary data from the original trajectory
        angle[j, :] = trajectory_data[j].q
        velocity[j, :] = trajectory_data[j].qd
        accel[j, :] = trajectory_data[j].qdd
        q0[j] = angle[j, 0]
        qf[j] = angle[j, -1]

        if q0[j] == qf[j]: # if the joint does not move originally, then prevent the optimizer from moving it during optimization
            flag[j] = True

    original_data = calculate_max_force(angle, velocity, contact_points_table, m_H, K, F_p)
    original_force = original_data[1]
    max_force_point = original_data[3]

    if original_force < F_p:
        print(f'max force is {original_force} N at Point {max_force_point+1}, trajectory is safe, no optimization need!')
        return
    else:
        print(f'max force is {original_force} N at Point {max_force_point+1}, optimization is needed')
    mu_t = (t_max - t_min) / 2 # initialize mean vector
    sig_t = (t_max - t_min) / 3 # initialize std.dev.vector

    while iter <= 100:

        lb = (t_min - mu_t) / sig_t
        ub = (t_max - mu_t) / sig_t
        trunc_gen_t = truncnorm(lb, ub, loc=mu_t, scale=sig_t) 
        tf_rand = trunc_gen_t.rvs(size=N) # truncated gaussian distribution of size N is stored here 
        contact_force_list_def = [('Force','f8'), ('Number','i2'), ('Force Diff', 'f8'), ('index', 'i2')] # Tuple definition. 1st column: contact force, 2nd column: index of random sample, 3rd column: delta F, 4th column: index of contact point
        contact_force_list = np.zeros(N, dtype = contact_force_list_def) # initialize tuple

        for i in range(N): # iterate through N randomly generated trajectory

            tg = generate_traj_time(tf_rand[i], step, start_joint_config, end_joint_config) # generate trajectory with randomly generated trajectory time, see traj.py
            for j in range(6):
                if flag[j] == False: # if joint is not stationary
                    q_mat[i, j, :] = tg[j].q # accept new trajectory data
                    qd_mat[i, j, :] = tg[j].qd
                    qdd_mat[i, j, :] = tg[j].qdd
                else: # if stationary
                    q_mat[i, j, :] = angle[j, :] # read original trajectory data
                    qd_mat[i, j, :] = velocity[j, :]
                    qdd_mat[i, j, :] = accel[j, :]

            force_data = calculate_max_force(q_mat[i, :, :], qd_mat[i, :, :], contact_points_table, m_H, K, F_p)
            max_of_all = force_data[1] 
            delta_f = force_data[2]
            index_max = force_data[3]
            contact_force_list[i] = (max_of_all, i, delta_f, index_max)
            print(f'List of contact force based on randomly generated trajectories:\n{contact_force_list}')
            print(f'Finished computation of set no. {i+1}')

        sorted_force_list = np.sort(contact_force_list, order='Force Diff') # sort energy consumption from lowest to highest
        print(f'List of maximal contact force evaluated by HKA:\n{sorted_force_list}')
        num_array = sorted_force_list['Number'] # the corresponding indices
        t_rand_index = num_array[0 : Nbest] # the indices of the Nbest acceleration time vectors
        post_t_rand = [tf_rand[i] for i in t_rand_index]
        post_mean_force.append(np.mean(sorted_force_list[0][0]))
        print(f'Current optimized acceleration time: {post_t_rand} s')

        mu_t_rand = np.mean(post_t_rand) # mean of Nbest candidates
        var_t_rand = np.var(post_t_rand) # variance of Nbest candidates
        new_mu_sig_t = kalman_gain(sig_t, var_t_rand, mu_t, mu_t_rand) # calculate Kalman gain, see HKA_kalman_gain.py
        mu_t = new_mu_sig_t[0] # new mean
        sig_t = new_mu_sig_t[1] # new std.dev.
        print(f'the diagonal of the covariance matrix:\n{var_t_rand}')

        if var_t_rand < 1e-4: # convergence criterion
            print(f'exited HKA at iter = {iter}')
            break
        
        print(f'End of iteration {iter}, begin iteration {iter+1}\n')
        iter = iter + 1

    post_mean_force = np.array(post_mean_force)
    force_opt = sorted_force_list[num_array[0]] 
    result_q = q_mat[num_array[0], :, :]
    result_qd = qd_mat[num_array[0], :, :]
    result_qdd = qdd_mat[num_array[0], :, :]
    np.savetxt('force_time_result_q.txt', result_q)
    np.savetxt('force_time_result_qd.txt', result_qd)
    np.savetxt('force_time_result_qdd.txt', result_qdd)
    np.savetxt('force_time_mean.txt', post_mean_force)
    print(f'Original max contact force: {original_force} N')
    print(f'Optimized total energy consumption: {force_opt} J')
    print(f'Optimization runtime: {ti.time() - start_time} seconds')
    print(f'Optimized initial acceleration: {result_qdd[:, 0]}')
    return result_q, result_qd, result_qdd   

start0 = np.array([0, 0, 0, 0, 0, 0])
end0 = np.array([-pi/2, 0, 0, -0, -0, 0])    

start1 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end1 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start2 = np.array([pi/2, -pi/2, pi/2, -pi/2, -pi/2, 0])
end2 = np.array([pi, -pi, 0, pi/4, -pi/2, pi])

start3 = np.array([0, 0, 0, 0, 0, 0])
end3 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])

start4 = np.array([pi, -pi/2, pi/2, -pi/2, -pi/2, 0])
end4 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start5 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end5 = np.array([2*pi/3, -pi/8, pi, -pi/2, 0, -pi/3])

trajectory_data = generate_traj_time(2, 201, start1, end1)

hka_force_opt(10, 4, trajectory_data, start1, end1)
