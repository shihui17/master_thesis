from math import pi, sqrt
import roboticstoolbox as rtb
import numpy as np
from traj import generate_traj_time
import matplotlib.pyplot as plt
import time as ti
from scipy.stats import truncnorm
from HKA_kalman_gain import *
import json

Yu = rtb.models.DH.Yu()
case = 4
if case == 0: # zero-pose, robot rotates around axis 1 for pi/2
    start = np.array([0, 0, 0, 0, 0, 0])
    end = np.array([-pi/2, 0, 0, -0, -0, 0])    
    points = [np.array([0, -0.13687, 0, 1]), np.array([-0.44995, 0, 0.12128, 1]), np.array([0.01559, 0, 0.12128, 1]), np.array([0.05, 0, 0.07938, 1]), 
              np.array([0, -0.05, 0.07938, 1]), np.array([-0.05, 0, 0.07938, 1]), np.array([0, 0, 0, 1])]
elif case == 1: # reverse of case 0
    start = np.array([-0, 0, 0, 0, 0, 0])
    end = np.array([pi/2, 0, 0, -0, -0, 0])
    points = [np.array([0, -0.13687, 0, 1]), np.array([-0.50519, 0, 0.12128, 1]), np.array([0, 0, 0.13687, 1]), np.array([0, 0, 0.10946, 1]), 
            np.array([0, 0.05, 0.07938, 1]), np.array([0, 0, 0.10946, 1]), np.array([0, 0, 0, 1])]
elif case == 2: 
    start = np.array([-0, -pi/2, 0, 0, 0, 0])
    end = np.array([0, 0, 0, -0, -0, 0])
    points = [np.array([0, -0.13687, 0, 1]), np.array([-0.50519, 0, 0.12128, 1]), np.array([0, 0.01559, 0.12128, 1]), np.array([0, 0.05, 0.07938, 1]), 
              np.array([0, 0, 0.10946, 1]), np.array([0, 0.05, 0.07938, 1]), np.array([0, 0, 0, 1])]
elif case == 3:
    start = np.array([-0, -pi/2, 0, 0, 0, 0])
    end = np.array([0, -pi, 0, -0, -0, 0])
    points = [np.array([0, -0.13687, 0, 1]), np.array([-0.50519, 0, 0.12128, 1]), np.array([-0.01559, 0.13687, 0, 1]), np.array([0, 0, 0.10946, 1]), 
            np.array([0, -0.05, 0.07938, 1]), np.array([0, 0, 0.10946, 1]), np.array([0, 0, 0, 1])]
elif case == 4:
    #start = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
    #end = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])
    start = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
    end = np.array([pi/2, -pi/2, pi/2, -pi/2, -pi/2, 0])
    points = [np.array([0, -0.13687, 0, 1]), np.array([-0.45, -0.05519, 0.12128, 1]), np.array([0, -0.05519, 0.12128, 1]), np.array([0, 0, 0.10946, 1]), 
            np.array([0, 0, 0.10946, 1]), np.array([-0.05, 0, 0.07938, 1]), np.array([0, 0, 0, 1])]
    
#traj = generate_traj_time(2, 201, start, end)
def gen_traj(vel_max, t_accel_rand, q0, qf, tf, time, V=None):
    """
    Generate a trapezoidal trajectory in joint space given parameters generated by HKA
    :param vel_max: maximal (allowed) angular velocity of the robot joint
    :param t_accel_rand: the acceleration time, randomly generated by HKA
    :param q0: initial joint angle at t = 0
    :param qf: end joint angle at t = tf
    :param tf: trajectory time
    :param time: the discretized time array, with time[0] = 0, time[-1] = tf
    :return q: array of joint angle with the size of len(time)
    :return qd: array of joint velocity with the size of len(time)
    :return qdd: array of joint acceleration with the size of len(time)
    """
    q = []
    qd = []
    qdd = []

    if V is None:
        # if velocity not specified, compute it
        V = (qf - q0) / tf * 1.5
    else:
        V = abs(V) * np.sign(qf - q0)
        if abs(V) < (abs(qf - q0) / tf):
            raise ValueError("V too small")
        elif abs(V) > (2 * abs(qf - q0) / tf):
            raise ValueError("V too big")
    
    vel_max = V

    if q0 == qf: # if the joint is stationary
        return (np.full(len(time), q0), np.zeros(len(time)), np.zeros(len(time))) # return q = q0, qd = 0, and qdd = 0 for the entire trajectory time
    else:
        a_accel_rand = (vel_max / t_accel_rand) # random acceleration, dependent on t_accel_rand generated by HKA
        t_brake_rand = 2 * (qf - q0) / vel_max + t_accel_rand - tf # the corresponding brake time
        a_brake_rand = vel_max / (tf - t_brake_rand) # the corresponding decceleration

        for tk in time: # the following trajectory planning is formulated according to the tools.trapezoidal method in roboticstoolbox
            if tk < 0:
                qk = q0
                qdk = 0
                qddk = 0
            elif tk <= t_accel_rand:
                qk = q0 + 0.5 * a_accel_rand * tk**2
                qdk = a_accel_rand * tk
                qddk = a_accel_rand
            elif tk <= t_brake_rand:
                qk = q0 + 0.5 * a_accel_rand * t_accel_rand**2 + vel_max * (tk - t_accel_rand)
                qk = vel_max * tk + q0 + 0.5 * a_accel_rand * t_accel_rand**2 - vel_max * t_accel_rand
                qdk = vel_max
                qddk = 0
            elif tk <= tf:
                qk = q0 + 0.5 * a_accel_rand * t_accel_rand**2 + vel_max * (t_brake_rand - t_accel_rand) + (vel_max * (tk - t_brake_rand) - 0.5 * a_brake_rand * (tk - t_brake_rand)**2)
                qdk = vel_max - a_brake_rand * (tk - t_brake_rand)
                qddk = -a_brake_rand
            else:
                qk = qf
                qdk = 0
                qddk = 0

            q.append(qk)
            qd.append(qdk)
            qdd.append(qddk)

        return (np.array(q), np.array(qd), np.array(qdd))

def get_contact_points():
    #points = [np.array([0, -0.13687, 0, 1]), np.array([-0.45, -0.05519, 0.12128, 1]), np.array([0, -0.05519, 0.12128, 1]), np.array([0, 0, 0.10946, 1]), 
            #np.array([0, 0, 0.10946, 1]), np.array([-0.05, 0, 0.07938, 1]), np.array([0, 0, 0, 1])]
    points = [np.array([0, -0.13687, 0, 1]), np.array([-0.44995, 0, 0.12128, 1]), np.array([0.01559, 0, 0.12128, 1]), np.array([0.05, 0, 0.07938, 1]), 
              np.array([0, -0.05, 0.07938, 1]), np.array([-0.05, 0, 0.07938, 1]), np.array([0, 0, 0, 1])]
    point_tuple_def = [('Point Coordinate', np.ndarray), ('Segment','i2')] # list that contains the energy consumption and the corresponding row index from assble_qdd
    point_tuple = np.zeros((7), dtype = point_tuple_def)
    #points = [np.array([0, -0.13687, 0, 1]), np.array([-0.50519, 0, 0.12128, 1]), np.array([-0.01559, 0.13687, 0, 1]), np.array([0, 0, 0.10946, 1]), np.array([0, 0, 0.10946, 1]), np.array([0, 0, 0.10946, 1]), np.array([0, 0, 0, 1])] # points of interest
    for i, p in enumerate(points):
        point_tuple[i][0] = p

    point_tuple[0][1] = 0
    point_tuple[1][1] = 1
    point_tuple[2][1] = 1
    point_tuple[3][1] = 2
    point_tuple[4][1] = 3
    point_tuple[5][1] = 4
    point_tuple[6][1] = 5

    return point_tuple

def unit_vector(q, qd, point, joint_num): # angle and velocity matrix should have the size of (201, 6), point = np.array([x, y, z, 1]), t: traj time

    Yu = rtb.models.DH.Yu() # import Yu with all relevant geometric and mechanical data
    #traj = generate_traj_time(2.5, 201)

    trafo_p = np.eye(4)
    trafo_p[:, -1] = point
    joint_jacobian = np.zeros((6, 6))   
    pose_list = []
    poses = Yu.fkine_all(q)
    #print(poses)

    for pose in (poses):
        pose_list.append(np.array(pose))  

    rf_p =  pose_list[joint_num+1] @ trafo_p @ np.array([0, 0, 0, 1]) # Position vector of p in RF0

    for count in range(joint_num+1):
        translation = rf_p - pose_list[count] @ np.array([0, 0, 0, 1])
        translation = translation[:3]
        rotation = pose_list[count] @ np.array([0, 0, 1, 0])
        rotation = rotation[:3]
        joint_jacobian[:3, count] = np.cross(rotation, translation)
        joint_jacobian[3:6, count] = rotation

    lin_ang = joint_jacobian @ qd # velocity[t, :joint_num+1]
    lin_vel = lin_ang[:3]
    length = np.linalg.norm(lin_vel, 2)
    if length <= 1e-3:
        vel_u = np.zeros(3)
    else:
        vel_u = np.divide(lin_vel, (np.linalg.norm(lin_vel, 2)))


    fkine_ee = pose_list[-1]
    r6_0 = fkine_ee[:, -1]
    #print(rf_p)
    #print(r6_0)
    r6p_0 = rf_p - r6_0 # Position vector from RF6 to p in RF0
    #print(r6p_0)
    T_0e = Yu.fkine(q)
    T_0e = T_0e.A
    R_0e = T_0e[:3, :3]
    R_e0 = np.transpose(R_0e)
    #print(T_e0)
    r6p_0 = r6p_0[:3]
    r6p_0 = R_e0 @ r6p_0
    #print(r6p_0)
    trafo_6p = np.eye(4)
    trafo_6p[:3, -1] = r6p_0[:3]
    #print(trafo_6p)
    Yu.tool = trafo_6p
    jacobian_p = Yu.jacob0(q)
    #joint_jacobian = jacobian_p

    M_q = Yu.inertia(q)
    Aq_inv = joint_jacobian @ np.linalg.inv(M_q) @ np.transpose(joint_jacobian)

    if all(element == 0 for element in vel_u):
        m_refl = 0
        #print('oh no')
    else:
        m_refl = 1/(np.transpose(vel_u) @ Aq_inv[:3, :3] @ vel_u)

    return vel_u, m_refl, lin_vel, rf_p

def get_original_jointdata(trajectory_data):
    mass_vec = np.zeros(6)
    angle = np.zeros((6, 201))
    velocity = np.zeros((6, 201))
    accel = np.zeros((6, 201))
    q0 = np.zeros(6)
    qf = np.zeros(6)

    for j in range(6):
        angle[j, :] = trajectory_data[j].q
        velocity[j, :] = trajectory_data[j].qd
        accel[j, :] = trajectory_data[j].qdd
        mass_vec[j] = Yu[j].m
        q0[j] = angle[j, 0]
        qf[j] = angle[j, -1]
               
    mass = np.linalg.norm(mass_vec, 1) # total mass of robot
    return angle, velocity, accel, mass, q0, qf

def hka_force_opt(N, Nbest, trajectory_data):
    """
    Randomly generate a set of trajectories and optimize for a most energy-efficient solution.
    Outputs the covariance matrix after each optimization iteration.
    Outputs the original and optimized energy consumption.
    Outputs algorithm runtime.
    Stores the optimized trajectory in prof_result_q.txt, prof_result_qd.txt and prof_result_qdd.txt, 

    :param N: size of the random trajectory set to be evaluated by HKA, 20 <= N <= 50 for optimal performance
    :param Nbest: the number of best sets of trajectory (i.e. Nbest candidates) to be considered by HKA
    :traj: original trajectory generated by tools.trapezoidal in roboticstoolbox
    :return result_q: the optimized angular trajectory
    :return result_qd: the optimized velocity trajectory
    :return result_qdd: the optimized acceleration trajectory
    """
    start_time = ti.time() # timer that records algorithm runtime
    vel_max = np.zeros(6)
    a = np.zeros(6)
    t_accel = np.zeros(6) 
    t_brake = np.zeros(6)
    t_min = np.zeros(6) # initialize minimal acceleration time, will later be derived from boundary conditions
    t_max = np.zeros(6) # initialize maximal acceleration time, will later be derived from boundary conditions
    #plot_trajectory(traj) # plot trajectory
    time = trajectory_data[6]
    step = trajectory_data[7] # total time step of the trajectory
    t0 = 0 # start
    tf = time[-1] # finish
    mu_t = np.zeros(6) # mean vector for Kalman
    sig_t =  np.zeros(6) # covariance vector for Kalman
    t_accel_rand = np.zeros((6, N)) # the matrix to store all N randomly generated acceleration time vectors for all 6 joints, hence the size 6 x N
    q0 = np.zeros(6)
    qf = np.zeros(6)
    q_mat = np.zeros((N, 6, step)) # matrix to store randomly generated angular trajectories of all 6 joints, N trajectories in total, hence the size N x 6 x step
    qd_mat = np.zeros((N, 6, step)) # randomly generated velocity trajectory
    qdd_mat = np.zeros((N, 6, step)) # randomly generated acceleration trajectory
    iter = 0 # iteration counter
    post_t_rand = np.zeros((6, Nbest)) # matrix to store the Nbest acceleration time vectors that yield the best energy efficiency

    m_refl_og = np.zeros((7, 201))
    lin_vel_og = np.zeros((7, 3, 201))
    vel_scalar_og = np.zeros((7, 201))
    m_refl = np.zeros((7, 201))
    lin_vel = np.zeros((7, 3, 201))
    vel_scalar = np.zeros((7, 201))
    rf_p_storage = np.zeros((7, 3, 201))
    contact_points_table = get_contact_points()
    original_jointdata =  get_original_jointdata(trajectory_data)
    angle = original_jointdata[0]
    velocity = original_jointdata[1]
    accel = original_jointdata[2]
    robot_mass = original_jointdata[3]
    q0 = original_jointdata[4]
    qf = original_jointdata[5]
    momentum_history = []
    momentum_per_iter = np.zeros((N, 7))
    reduced_mass = np.zeros((7, 201))
    equi_contact_force = np.zeros((7, 201))

    K = 35000 # Face is smashed against the robot, ouch!
    F_p = 210 # Face is smashed against the robot, ouch!
    m_H = 40 # Face is smashed against the robot, ouch!
    for t in range(201):

        q = angle[:, t]
        qd = velocity[:, t]

        for n, point_list in enumerate(contact_points_table):
            #print(f'r = {r}\n')
            result = unit_vector(q, qd, point_list[0], point_list[1])
            lin_vel_og[n, :, t] = result[2]
            vel_scalar_og[n, t] = np.linalg.norm(lin_vel_og[n, :, t], 2)
            m_refl_og[n, t] = result[1]

    momentum_og = np.multiply(vel_scalar_og, m_refl_og)
    max_momentum_og = np.amax(momentum_og, axis=1)
    print(max_momentum_og)

    for j in range(6): 

        if q0[j] == qf[j]: # if the joint does not move originally, then prevent the optimizer from moving it during optimization
            vel_max[j] = 0
            t_accel[j] = 0
            t_brake[j] = tf
            a[j] = 0
            t_min[j] = abs(vel_max[j] / 100)
            t_max[j] = abs(tf / 3 + vel_max[j] / 100)

        #elif j == 0:
        #    vel_max[j] = 10
        #    t_accel[j] = np.round((q0[j] - qf[j] + vel_max[j] * tf) / vel_max[j], 2) # end of acceleration, rounded to 2 decimals to exactly match the time points in traj[6]
        #    t_brake[j] = np.round(tf - t_accel[j], 2) # start of braking
        #    a[j] = vel_max[j] / t_accel[j]
        #    t_min[j] = abs(vel_max[j] / 100) # boundary condition: maximal angular acceleration 250 s^-2
        #    print(t_min[j])
        #    t_max[j] = abs(tf - tf / 3 - vel_max[j] / 100) # maximal allowed acceleration time is reached when the joint has to brake with the maximal angular acceleration in order to reach end configuration (250 s^-2)
        #    print(t_max[j])
        else:
            vel_max[j] = (qf[j] - q0[j]) / tf * 1.5 
            t_accel[j] = np.round((q0[j] - qf[j] + vel_max[j] * tf) / vel_max[j], 2) # end of acceleration, rounded to 2 decimals to exactly match the time points in traj[6]
            t_brake[j] = np.round(tf - t_accel[j], 2) # start of braking
            a[j] = vel_max[j] / t_accel[j]
            t_min[j] = abs(vel_max[j] / 100) # boundary condition: maximal angular acceleration 250 s^-2
            t_max[j] = abs(tf - tf / 3 - vel_max[j] / 100) # maximal allowed acceleration time is reached when the joint has to brake with the maximal angular acceleration in order to reach end configuration (250 s^-2)

    mu_t = t_accel # initialize mean vector
    sig_t = (t_max - t_min) / 2 # initialize std.dev.vector
    while iter <= 150:

        for j in range(6): # generate truncated gaussian distribution to account for boundary conditions
            lb = (t_min[j] - mu_t[j]) / sig_t[j]
            ub = (t_max[j] - mu_t[j]) / sig_t[j]
            trunc_gen_t = truncnorm(lb, ub, loc=mu_t[j], scale=sig_t[j]) 
            t_accel_rand[j, :] = trunc_gen_t.rvs(size=N) # truncated gaussian distribution of size N is stored here
          
        max_momentum_list_def = [('Momentum','f8'), ('Number','i2'), ('Point', 'i2')] # define a tuple that contains the energy consumption and the corresponding row index
        max_momentum_list = np.zeros((N), dtype = max_momentum_list_def) # initialize tuple

        for i in range(N): # iterate through trajectory set
            for j in range(6): # iterate through each joint
                max_velocity = vel_max[j]
                t_accel_r = t_accel_rand[j, i]
                q0_r = q0[j]
                qf_r = qf[j] 
                tg = gen_traj(max_velocity, t_accel_r, q0_r, qf_r, tf, time)
                q_mat[i, j, :] = tg[0]
                qd_mat[i, j, :] = tg[1]

            for t in range(201):

                q = q_mat[i, :, t]
                qd = qd_mat[i, :, t]

                for n, point_list in enumerate(contact_points_table):
                    #print(f'r = {r}\n')
                    result = unit_vector(q, qd, point_list[0], point_list[1])
                    lin_vel[n, :, t] = result[2]
                    vel_scalar[n, t] = np.linalg.norm(lin_vel[n, :, t], 2)
                    m_refl[n, t] = result[1]

            momentum = np.multiply(vel_scalar, m_refl)
            max_momentum = np.amax(momentum, axis=1)
            momentum_per_iter[i, :] = max_momentum
            max_of_all = np.amax(max_momentum)
            index_max_of_all = np.argmax(max_momentum)
            max_momentum_list[i] = (max_of_all, i, index_max_of_all)
            print(max_momentum_list)
            print(f'finished computation of set no. {i+1}')

        sorted_force_list = np.sort(max_momentum_list, order='Momentum') # sort energy consumption from lowest to highest
        #print(sorted_force_list)
        num_array = sorted_force_list['Number'] # the corresponding indices
        t_rand_index = num_array[0 : Nbest] # the indices of the Nbest acceleration time vectors
        momentum_history.append(momentum_per_iter.tolist())

        for j in range(6):
            post_t_rand[j, :] = [t_accel_rand[j, i] for i in t_rand_index] # store accel time vectors into a big matrix to run through HKA
        #print(post_t_rand)

        mu_t_rand = np.mean(post_t_rand, 1) # mean of Nbest candidates
        var_t_rand = np.var(post_t_rand, 1) # variance of Nbest candidates
        new_mu_sig_t = kalman_gain(sig_t, var_t_rand, mu_t, mu_t_rand) # calculate Kalman gain, see HKA_kalman_gain.py
        mu_t = new_mu_sig_t[0] # new mean
        sig_t = new_mu_sig_t[1] # new std.dev.
        print(f'the diagonal of the covariance matrix:\n{var_t_rand}')

        if (all(i < 1e-4 for i in var_t_rand) == True) or (max_of_all < 65): # convergence criterion
            print(f'exited HKA at iter = {iter}')
            break
        
        print(f'End of iteration {iter}, begin iteration {iter+1}\n')
        iter = iter + 1
            #To plot search domain
            #if iter == 0:
            #    fig.suptitle(f'Search domain for Joint 1', fontsize=16)
            #    ax1.plot(time, q_mat[i, 0, :])
            #    ax1.set_xlabel('Travel Time in s')
            #    ax1.set_ylabel('Joint angle in rad')
            #    ax2.plot(time, qd_mat[i, 0, :])
            #    ax2.set_xlabel('Travel Time in s')
            #    ax2.set_ylabel('Joint velocity in rad/s')

    force_opt = max_momentum_list[num_array[0]] 
    result_q = q_mat[num_array[0], :, :]
    result_qd = qd_mat[num_array[0], :, :]
    result_qdd = qdd_mat[num_array[0], :, :]
    np.savetxt('momentum_result_q.txt', result_q)
    np.savetxt('momentum_result_qd.txt', result_qd)
    np.savetxt('momentum_result_qdd.txt', result_qdd)

    with open('momentum_history.json', 'w') as file:
        json.dump(momentum_history, file)

    print(f'Original max contact force: ')
    print(f'Optimized total energy consumption: {force_opt} J')
    print(f'Optimization runtime: {ti.time() - start_time} seconds')
    print(f'Optimized initial acceleration: {result_qdd[:, 0]}')
    return result_q, result_qd, result_qdd   

def optimize_momentum(trajectory_data):

    m_refl = np.zeros((7, 201))
    lin_vel = np.zeros((7, 3, 201))
    vel_scalar = np.zeros((7, 201))
    rf_p_storage = np.zeros((7, 3, 201))
    contact_points_table = get_contact_points()
    original_jointdata =  get_original_jointdata(trajectory_data)
    angle = original_jointdata[0]
    velocity = original_jointdata[1]
    accel = original_jointdata[2]
    robot_mass = original_jointdata[3]
    reduced_mass = np.zeros((7, 201))
    equi_contact_force = np.zeros((7, 201))

    K = 75 # Face is smashed against the robot, ouch!
    F_p = 65 # Face is smashed against the robot, ouch!
    m_H = 4.4 # Face is smashed against the robot, ouch!


    for t in range(201):
        #if t == 1:
        #    print(q)
        q = angle[:, t]
        qd = velocity[:, t]

        for i, point_list in enumerate(contact_points_table):
            #print(f'r = {r}\n')
            result = unit_vector(q, qd, point_list[0], point_list[1])
            lin_vel[i, :, t] = result[2]
            vel_scalar[i, t] = np.linalg.norm(lin_vel[i, :, t], 2)
            m_refl[i, t] = result[1]
            if m_refl[i, t] == 0:
                reduced_mass[i, t] = 0
            else:
                reduced_mass[i, t] = 1 / (1 / m_refl[i, t] + 1 / m_H)
            equi_contact_force[i, t] = vel_scalar[i, t] * sqrt(reduced_mass[i, t] * K)
            rf_p_storage[i, :, t] = result[3][:3]

    print(equi_contact_force)
    print(m_refl)
    print(np.amax(equi_contact_force, axis = 1))
    print(np.amax(m_refl, axis = 1))
    np.savetxt("equivalent_force.txt", equi_contact_force)

start0 = np.array([0, 0, 0, 0, 0, 0])
end0 = np.array([-pi/2, 0, 0, -0, -0, 0])    

start1 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end1 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start2 = np.array([pi/2, -pi/2, pi/2, -pi/2, -pi/2, 0])
end2 = np.array([pi, -pi, 0, pi/4, -pi/2, pi])

start3 = np.array([0, 0, 0, 0, 0, 0])
end3 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])

start4 = np.array([pi, -pi/2, pi/2, -pi/2, -pi/2, 0])
end4 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start5 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end5 = np.array([2*pi/3, -pi/8, pi, -pi/2, 0, -pi/3])

trajectory_data = generate_traj_time(2, 201, start1, end1)

hka_force_opt(20, 4, trajectory_data)
"""
n = 6
m_refl[n, 0] = m_refl[n, 1]
m_refl[n, -1] = m_refl[n, -2]
print(f'Reflected mass: \n{m_refl[n, :]}')
#print(lin_vel[n, :, :])
vel_abs = np.linalg.norm(lin_vel[n, :, :], axis=0)

#print(vel_abs)
refl_max = np.argmax(m_refl[n, :])
#print(refl_max)
#print(m_refl[n, refl_max])
momentum = np.multiply(vel_abs, m_refl[n, :])
print(f'Momentum trajectory: \n{momentum}')
#ax = plt.axes(111, projection='3d')
print(vel_abs)

lin_vel_plot = lin_vel[n, :, :]
start = np.transpose(rf_p_storage[n, :, :])
#print(rf_p_storage[n, :, :])
xline2 = start[:, 0]
yline2 = start[:, 1]
zline2 = start[:, 2]


Yu = rtb.models.DH.Yu()
start1 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end1 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start2 = np.array([pi/2, -pi/2, pi/2, -pi/2, -pi/2, 0])
end2 = np.array([pi, -pi, 0, pi/4, -pi/2, pi])

start3 = np.array([0, 0, 0, 0, 0, 0])
end3 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])

start4 = np.array([pi, -pi/2, pi/2, -pi/2, -pi/2, 0])
end4 = np.array([pi, -pi/3, pi/2, -5*pi/6, -0.58*pi, -0.082*pi])

start5 = np.array([0, -pi/2, pi/2, -pi/2, -pi/2, 0])
end5 = np.array([2*pi/3, -pi/8, pi, -pi/2, 0, -pi/3])
trajectory_data = generate_traj_time(2, 201, start1, end1)
"""
"""
ax = plt.axes(111, projection='3d')
#ax.set_xlim([-8, 8])
#ax.set_ylim([-8, 8])
#ax.set_zlim([-1, 1])
#ax.set_xlim(0, 1)
#ax.set_ylim(0, 1)
#ax.set_zlim(0, 1)
#ax.set_aspect('equal', adjustable='box')
ax.axis('scaled')
ax.set_xlabel('x coordinate in m')
ax.set_ylabel('Y coordinate in m')
ax.set_zlabel('Z coordinate in m')
#ax.plot3D(xline, yline, zline)
#ax.plot3D(xline1, yline1, zline1, color='blue')
ax.plot3D(xline2, yline2, zline2, color='red', linewidth=1, label='Trajectory of center of mass')
"""
"""
for i in range(201):
#for i in range(5):
    if i == 0:
        ax.quiver(start[i, 0], start[i, 1], start[i, 2], lin_vel_plot[0, i], lin_vel_plot[1, i], lin_vel_plot[2, i], length=0.4*np.linalg.norm((start[i, :]-lin_vel_plot[:, i]), 2), arrow_length_ratio=0.05, normalize='false', color='green', label='Momentum vector of robot on its center of mass')
    elif i % 4 == 0:
    #ax.quiver(start[i, 0], start[i, 1], start[i, 2], lin_max[i, 0], lin_max[i, 1], lin_max[i, 2], arrow_length_ratio=0.01, length=np.linalg.norm((start[i, :]-lin_max[i, :]), 2), normalize='True')
        ax.quiver(start[i, 0], start[i, 1], start[i, 2], lin_vel_plot[0, i], lin_vel_plot[1, i], lin_vel_plot[2, i], length=0.4*np.linalg.norm((start[i, :]-lin_vel_plot[:, i]), 2), arrow_length_ratio=0.05, normalize='false', color='green')#length=0.01*np.linalg.norm((start[i, :]-lin_max[i, :]), 2), normalize='True', arrow_length_ratio=0.05, color='blue')
    #ax.quiver(T_cm[i, 0], T_cm[i, 1], T_cm[i, 2], lin_max[i, 0], lin_max[i, 1], lin_max[i, 2], arrow_length_ratio=0.01, length=np.linalg.norm((start[i, :]-lin_max[i, :]), 2), normalize='True')
#plt.show()
#ax.legend()
#plt.show()
"""

"""
fig, (ax1, ax2) = plt.subplots(2, 1)
ax1.plot(traj[6], momentum)
ax1.set_xlabel('Travel Time in s')
ax1.set_ylabel('momentum in kg*m/s')

ax2.plot(traj[6], m_refl[n, :])
ax2.set_xlabel('Travel Time in s')
ax2.set_ylabel('reflected mass in kg')
ax2.set_ylim([0, 5])
plt.show()
"""